import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class LostCharacter
{
	public int[] getmins(String[] str)
	{
        int n = str.length;
        int[] ret = new int[n];
        for (int i = 0; i < n; i++) {
            ArrayList<String> sList = new ArrayList<String>();
            String target = "", curr;
            for (int j = 0; j < n; j++) {
                if (j == i) {
                    curr = target = str[j].replace('?', 'a');
                } else {
                    curr = str[j].replace('?', 'z');
                }
                sList.add(curr);
            }
            Collections.sort(sList);
            ret[i] = sList.indexOf(target);
        }
        return ret;
    }
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, String[] p0, boolean hasAnswer, int[] p1) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print("\"" + p0[i] + "\"");
		}
		System.out.print("}");
		System.out.println("]");
		LostCharacter obj;
		int[] answer;
		obj = new LostCharacter();
		long startTime = System.currentTimeMillis();
		answer = obj.getmins(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.print("\t" + "{");
			for (int i = 0; p1.length > i; ++i) {
				if (i > 0) {
					System.out.print(",");
				}
				System.out.print(p1[i]);
			}
			System.out.println("}");
		}
		System.out.println("Your answer:");
		System.out.print("\t" + "{");
		for (int i = 0; answer.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(answer[i]);
		}
		System.out.println("}");
		if (hasAnswer) {
			if (answer.length != p1.length) {
				res = false;
			} else {
				for (int i = 0; answer.length > i; ++i) {
					if (answer[i] != p1[i]) {
						res = false;
					}
				}
			}
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		String[] p0;
		int[] p1;
		
		// ----- test 0 -----
		p0 = new String[]{"abc","bcd","cde","cdf","bbc"};
		p1 = new int[]{0,2,3,4,1};
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new String[]{"?ala","ara","baba"};
		p1 = new int[]{0,0,1};
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new String[]{"a?","a","a","ab","aa"};
		p1 = new int[]{2,0,0,3,2};
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new String[]{"s?nu?ke","sm??eke","?sna?ke","so?th?e","shake??"};
		p1 = new int[]{0,1,0,2,0};
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = new String[]{"?","z?","zz?","zzz?","zzzz?","zzzzz?","zzzzzz?"};
		p1 = new int[]{0,1,2,3,4,5,6};
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// In this problem we are dealing with strings of lowercase English letters.
	// When comparing our strings, we are using the standard lexicographic order.
	// For example, "cat" < "do" < "dog" < "done".
	// (See Notes for a formal definition.)
	// 
	// Suppose that L is a list of strings and that S is one of those strings.
	// The position of S in L is the 0-based index of the first occurrence of S after L is sorted lexicographically.
	// (Equivalently, the position of S in L can be defined as the number of strings in L that are strictly smaller than S.)
	// 
	// For example, for the list L = {"abc", "bcd", "cde", "cdf", "bbc"}, the corresponding positions would be {0, 2, 3, 4, 1}.
	// For the list L = {"a", "a", "b", "b", "c", "c"} the positions would be {0, 0, 2, 2, 4, 4}.
	// 
	// Wolf Sothe has found an old list of strings.
	// Some characters in the list were damaged beyond recognition.
	// You are given the list as a String[] str.
	// In str, the damaged characters are represented by the character '?' (question mark).
	// 
	// Return a int[] with as many elements as str.
	// For each valid i, the i-th element of the return value should be the smallest possible position of the i-th element of Sothe's list.
	// 
	// DEFINITION
	// Class:LostCharacter
	// Method:getmins
	// Parameters:String[]
	// Returns:int[]
	// Method signature:int[] getmins(String[] str)
	// 
	// 
	// NOTES
	// -Given two strings A and B, we say that A is smaller than B if either A is a proper prefix of B, or there is a non-negative integer i such that A[i]<B[i] and for all j<i we have A[j]=B[j].
	// 
	// 
	// CONSTRAINTS
	// -str will contain between 1 and 50 elements, inclusive.
	// -Each element in str will contain between 1 and 50 characters, inclusive.
	// -Each character in str will be either a lowercase English letter ('a'-'z'), or '?'.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {"abc","bcd","cde","cdf","bbc"}
	// 
	// Returns: {0, 2, 3, 4, 1 }
	// 
	// This is the first example from the problem statement.
	// As there are no damaged letters, there is only one possible lexicographical order and you should return the corresponding positions.
	// 
	// 1)
	// {"?ala","ara","baba"}
	// 
	// Returns: {0, 0, 1 }
	// 
	// In this test case we have one damaged character.
	// If the damaged character was an 'a', the positions were {0,1,2}.
	// Otherwise, the positions were {2,0,1}.
	// Hence, the smallest possible position of "?ala" is 0, the smallest possible position of "ara" is 0, and the smallest possible position of "baba" is 1.
	// 
	// 2)
	// {"a?","a","a","ab","aa"}
	// 
	// Returns: {2, 0, 0, 3, 2 }
	// 
	// Sothe's list may contain duplicates.
	// 
	// 3)
	// {"s?nu?ke","sm??eke","?sna?ke","so?th?e","shake??"}
	// 
	// Returns: {0, 1, 0, 2, 0 }
	// 
	// 
	// 
	// 4)
	// {"?","z?","zz?","zzz?","zzzz?","zzzzz?","zzzzzz?"}
	// 
	// Returns: {0, 1, 2, 3, 4, 5, 6 }
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
